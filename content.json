{"pages":[{"title":"404","text":"","path":"404/index.html","date":"05-27","excerpt":""},{"title":"about me","text":"带来了我自己，不只是为着确认，偶尔有风，似乎比传说中的永恒，更宜于慰藉平生 关于我典型的双子，三分钟热度，敢想敢做，但又时常路遇瓶颈 永远的长不大，喜欢的女孩永远追不到，家里永远催着谈对象却又总缺对象 不是长得不好看，而是这几年青春全特么给游戏和动漫了，圈子小了，养成了死肥宅气息 为人面善，目前从事Java后台数据安全和大数据挖掘方向研究 爱好动漫：全职猎人、海贼王、进击的巨人、Fate…. 音乐：麻油叶、陈粒、万能青年旅店、 游戏：地下城与勇士、 文学：郭敬明《愿风裁尘》、川端康成《雪国》、《古都》、网络文学《神墓》 联系方式如果你的爱好也有这些，或者说你想和我交流技术，那就交个朋友吧！ QQ:979480161","path":"about me/index.html","date":"05-27","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"05-27","excerpt":""}],"posts":[{"title":"REST理解","text":"#Apache Ranger Admin REST ​ 在对大数据生态领域里，有HDFS、YARN、Hive、Hbase、Storm….在未进行保护,资源对用户更多的是直接进行HTTP资源请求，安全性不高。而Apache针对这提供了统一的资源管理插件Apache Ranger Admin Plugin。 ​ 在对Apache Ranger Admin Plugin其源码分析中，发现便是采用了REST API架构，其日志统计采用Log4j，数据库支持MySQL、SqlServer、PostgreSQL、Oracle，对象管理和事物采用了Spring技术、对象映射采用了JPA、数据交互层采用REST架构中的XML、JASON ##REST架构 网络上的所有资源都被抽象为资源 每个资源都有唯一的资源标识符 同一个资源有多种表现形式（xml、json等） 对资源的各种操作不会改变资源的标识符 所有操作都是无状态的 符合REST原则的架构方式可称为RESTful 并且测试通过Mock，实现更好的前后端的分离 REST规范 资源定位 定位资源的URL风格 资源操作 HTTP协议中的GET、POST、PUT、DELETE动作处理资源的增删改查 资源展示 RESTful1. 符合REST原则的架构方式可称为`RESTful`` 2. ``RESTful Web service`是一种常见的REST应用，遵守了REST风格的web服务,REST式的Web服务是一种ROA(*The Resource-Oriented Architecture*)(*面向资源的架构*) 1234/emp/1 HTTP GET 用于从服务器获取数据/emp/1 HTTP DELETE 删除数据 /emp/1 HTTP PUT 更新资源/emp/1 HTTP POST 添加新资源 URI统一资源定位符，每一个资源指向特定的资源，要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或识别符 实现RESTful框架1.统一的响应结构 ​ 需要首先确定返回的 JSON 响应结构是统一的，也就是说，每个 REST 请求将返回相同结构的 JSON 响应结构，其中包含两部分：元数据与返回值，其中，元数据表示操作是否成功与返回值消息等，返回值对应服务端方法所返回的数据 1234567&#123; \"meta\": &#123; \"success\": true, \"message\": \"ok\" &#125;, \"data\": ... &#125; 此外，为了能够在框架中映射以上 JSON 响应结构，我们需要编写一个 Response 类与其对应 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Title: 统一响应结构 * Description:使用REST框架实现前后端分离架构，我们需要首先确定返回的JSON响应结构是统一的， * 也就是说，每个REST请求将返回相同结构的JSON响应结构。不妨定义一个相对通用的JSON响应结构，其 * 中包含两部分：元数据与返回值，其中，元数据表示操作是否成功与返回值消息等，返回值对应服务端方法所返回的数据。 * &#123; \"meta\": &#123; \"success\": true, \"message\": \"ok\" &#125;, \"data\": ... &#125; */public class Response &#123; private static final String OK = \"ok\"; private static final String ERROR = \"error\"; private Meta meta; // 元数据 private Object data; // 响应内容 public Response success() &#123; this.meta = new Meta(true, OK); return this; &#125; public Response success(Object data) &#123; this.meta = new Meta(true, OK); this.data = data; return this; &#125; public Response failure() &#123; this.meta = new Meta(false, ERROR); return this; &#125; public Response failure(String message) &#123; this.meta = new Meta(false, message); return this; &#125; public Meta getMeta() &#123; return meta; &#125; public Object getData() &#123; return data; &#125; /** * Title: 请求元数据 * @author rico * @created 2017年7月4日 下午5:08:12 */ public class Meta &#123; private boolean success; private String message; public Meta(boolean success) &#123; this.success = success; &#125; public Meta(boolean success, String message) &#123; this.success = success; this.message = message; &#125; public boolean isSuccess() &#123; return success; &#125; public String getMessage() &#123; return message; &#125; &#125;&#125; ​ 以上 Response 类包括两类通用返回值消息：ok 与 error，还包括两个常用的操作方法：success() 与 failure()，通过一个内部类来展现元数据结构，我们在下文中多次会使用该 Response 类。 实现该 REST 框架需要考虑许多问题，首当其冲的就是前后数据流转问题，即 HTTP 消息与 Java 对象之间的转化问题 2.前后台数据流转 … …//TODO Spring MVC对RESTful的支持 利用@RequestMapping指定处理请求的URI模板和HTTP请求的动作类型 利用@PathVariable将URI请求模板中的变量映射到处理方法参数上 利用Ajax，在客户端发出PUT、DELETE动作的请求 例如： 1234@RequestMapping(value=\"/&#123;id&#125;\",method=RequestMethod.GET)public String toUpdate(@PathVariable(\"id\") Integer id,Model model)&#123; ...&#125; ###RequestMapping的一般格式 12345678@RequestMapping(value=\"/&#123;id&#125;\",method=RequestMethod.GET)@RequestMapping(value=\"/&#123;id&#125;\",method=RequestMethod.POST)@RequestMapping(value=\"/&#123;id&#125;\",method=RequestMethod.DELETE) @ResponseBody@RequestMapping(value=\"/&#123;id&#125;\",method=RequestMethod.PUT) 客户端发出PUT、DELETE请求​ 采用Ajax方式发送PUT和DELETE请求 123456789$.ajax( &#123; type : \"DELETE\", url : \"/spring_crud_restful/emp/deleteEmp/\" + id, dataType : \"json\", success : function(data) &#123; alert(data); location.href = \"/spring_crud_restful/emp/listEmp/1\"; &#125; &#125;);","path":"REST/","date":"05-27","excerpt":"","preview":"http://wx4.sinaimg.cn/mw690/e4b98032gy1frqdk534wtj20go0icn07.jpg"},{"title":"postgresql","text":"PostgreSQL[TOC] 一、定义： PostgreSQL是一个开源的、对象—关系数据库管理系统(ORDBMS)； 用于存储数据; 支持最佳做法，并允许在处理请求时检索它们； PostgreSQL是跨平台的，可以在许多操作系统上运行，如Linux，Microsoft Windows 二、特性： 在PostgreSQL中，表可以设置为从“父”表继承其特征； PostgreSQL支持文本，图像，声音和视频，并包括用于C/C++，Java，Python和开放数据库连接(ODBC)的编程接口； SQL支持，复杂SQL查询，SQL子选择，外键，触发器，视图，事务，多进程并发控制(MVCC) 三、数据类型： 任意精度的数值； 数组； 几何图元； 无限制长度文本； IP地址与IPv6地址； 无类域间路由地址块，MAC地址； 用户自定义数据类型 四、Java连接到PostgreSQL数据库 需要确保在机器上安装了PostgreSQL JDBC和Java; 从postgresql-jdbc存储库下载最新版本的postgresql-(VERSION).jdbc.jar; 在类路径中添加下载的jar文件postgresql-(VERSION).jdbc.jar 在PostgreSQL安装目录中找到pg_hba.conf文件并添加以下行： 123&gt; # IPv4 local connections:&gt; host all all 127.0.0.1/32 md5&gt; 重新启动postgres服务器: 12&gt; [root@host]# service postgresql restart&gt; 连接示例： 12345678910111213141516171819202122232425import java.sql.Connection;import java.sql.DriverManager;public class PostgreSQLJDBC &#123; public static void main(String args[]) &#123; Connection c = null; try &#123; //加载驱动 Class.forName(&quot;org.postgresql.Driver&quot;); //获得连接Connection对象 c = DriverManager.getConnection(&quot;jdbc:postgresql://localhost:5432/testdb&quot;,&quot;postgres&quot;, &quot;123&quot;); //执行SQL ... //处理结果、结果集 ... &#125; catch (Exception e) &#123; e.printStackTrace(); System.err.println(e.getClass().getName()+&quot;: &quot;+e.getMessage()); System.exit(0); &#125; //关闭连接 ... System.out.println(&quot;Opened database successfully&quot;); &#125;&#125; 123- java代码层面、对于PostgreSQL驱动架包的操作API和MySQL驱动架包API基本一致；- 功能性API有，Connection、Statement、ResultSet- 功能性函数有executeUpdate、executeQuery、getInt、getString 五、建表语句： 12345678910111213141516171819202122&gt; 创建数据库：create database testdb;&gt; 删除数据库：drop database testdb;&gt; 创建表：&gt; 方式一：使用UI创建表：&gt; 创建表的数据库——&gt;public 、架构——&gt;数据表——&gt;右键建表——&gt;指定表名和属性列名、数据类型&gt; 方式二：&gt; 使用查询工具SQL编辑器创建表：&gt; create table public.student2&gt; (&gt; id integer NOT NULL,&gt; name character(100),&gt; subjects character(1),&gt; CONSTRAINT student2_pkey PRIMARY KEY (id)&gt; )&gt; WITH (&gt; OIDS=FALSE&gt; );&gt; ALTER TABLE public.student2 OWNER TO postgres;&gt; COMMENT ON TABLE public.student2 IS &apos;这是一个学生信息表2&apos;;&gt; 删除表：&gt; drop table student2;&gt; 六、INSERT:123456INSERT INTO public.EMPLOYEES( ID, NAME, AGE, ADDRESS, SALARY) VALUES(1, &apos;Maxsu&apos;, 25, &apos;海口市人民大道2880号&apos;, 109990.00 ), (2, &apos;minsu&apos;, 25, &apos;广州中山大道 &apos;, 125000.00 ), (3, &apos;李洋&apos;, 21, &apos;北京市朝阳区&apos;, 185000.00), (4, &apos;Manisha&apos;, 24, &apos;Mumbai&apos;, 65000.00), (5, &apos;Larry&apos;, 21, &apos;Paris&apos;, 85000.00); 七、UPDATE:1update public.employees set age=29,salary=9800 where id=1; 八、DELETE:1delete from public.employee where id=1; 九、SELECT:1SELECT ID, NAME, AGE, SALARY FROM EMPLOYEES; 十、分页sql： PostgreSQL不支持mysql中的select * from xxx limit x,y; 支持：select * from xxx limit pagesize offset offsetNum ; 1234- pagesize是固定的，即每页显示多少记录，而offsetNum则是需要我们去计算的； - offsetNum＝（当前页数－1）*pagesize//如果是第一页，假设每页显示10条数据，则是（1-1）＊10,第二页则是（2-1）＊10- total＝（查到的数 /pagesize）/有余进一 - 如：select * from emp limit 10 offset 30; //每页显示10条记录，显示第四页的数据 十一、MySQL与PostgreSQL的比较：PostgreSQL: 可以存储 array 和 json, 可以在 array 和 json 上建索引, 甚至还能用表达式索引; 支持 trigram 索引,自带全文搜索功能; PG 的可以使用函数和条件索引，这使得PG数据库的调优非常灵活; FDW(Foreign data wrappers)用统一的SQL，去访问其他关系数据库，其他NoSQL数据库，HBase，甚至是各种格式的文件，操作系统信息，在线数据集 MySQL: mysql的innodb引擎，可以充分优化利用系统所有内存，超大内存下PG对内存使用的不那么充分; MySQL有一些实用的运维支持，如 slow-query.log ; 基于MySql 的开源著名应用多","path":"postgresql/","date":"05-27","excerpt":"","preview":"http://wx1.sinaimg.cn/mw690/e4b98032ly1frpw1992wnj20qo0nqdi8.jpg"},{"title":"Spring","text":"##Spring [TOC] ###注解 ###@Scheduled实现定时任务 applicationContext.xml中配置：12345&lt;!--配置任务线程池--&gt;&lt;task:executor pool-size=\"10\" queue-capacity=\"10000\" rejection-policy=\"CALLER_RUNS\"/&gt;&lt;task:scheduler id=\"scheduler\" pool-size=\"10\"/&gt;&lt;!--配置annotation启动方式--&gt;&lt;task:annotation-driven executor=\"executor\" scheduler=\"scheduler\"/&gt; 2.实现方法前添加注解@Scheduled(cron=”0 10 * ?”) @Scheduled应该写在实现上； 注入方法不能有返回值； 实现类上要有@Component注解； cron参数 ###JPAJava对象持久化规范 Hibernate作为Jboss服务器中JPA的默认实现； Oracle的Weblogic使用EclipseLink(以前叫TopLink)作为默认的JPA实现； IBM的Websphere和Sun的Glassfish默认使用OpenJPA(Apache的一个开源项目)作为其默认的JPA实现 是java实体bean到关系型数据库的规范 配置文件 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence version=\"1.0\" xmlns=\"http://java.sun.com/xml/ns/persistence\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd\"&gt; &lt;persistence-unit name=\"持久化单元名\" transaction-type=\"JTA\"&gt; &lt;jta-data-source&gt;使用JCA部署在javaEE服务器上的数据源JNDI&lt;/jta-data-source&gt; &lt;！--指定JPA实现提供者，不指定就采用JavaEE服务器默认的JPA提供者，这里以OpenJPA为例--&gt;&lt;provider&gt;org.apache.openjpa.persistence.PersistenceProviderImpl&lt;/provider&gt;&lt;class&gt;实体bean全路径名&lt;/class&gt;…… &lt;properties&gt; &lt;!--配置JPA实现提供者的一些信息--&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 可以在持久化策略文件中配置多个持久化单元persistence-unit，在使用分布式数据库时经常配置多个持久化单元 ###实体Bean的开发 实体Bean上添加@Entity注解，表示其为实体Bean 实体Bean必须序列化 @Table(name=&quot;数据库表名&quot;注解，标识映射到数据库的的表名 必须有一个@ID标识的主键，123@ID@Column(name=\"列名\")@GeneratedValue(Strategy=GenerationType.Auto) 支持字段注解(变量)、属性注解(set/get方法)；但在实体类中，不能混用；| @Entity | @Table | @ID | @GeneratedValue | @Column || ——- | ———– | —- | —————————- | ———– || 空 | name=”表名” | 空 | strategy=GenerationType.AUTO | name=”列名” | ###@Temporal标注时间类型 DATE TIME TIMESTAMP###@Transientbean中某一属性不想被映射至数据库###@Lob将属性持久化为Blob或者Clob类型，为大数据类型###@Basic是否延迟加载 延迟加载：@Basic(fetch=FetchType.Lazy) 非延迟加载：@Basic(fetch=FetchType.EAGER)","path":"Spring/","date":"05-27","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"hello-world/","date":"05-27","excerpt":""}]}